/*
 * Copyright © 2012 Rob Clark <robclark@freedesktop.org>
 * Copyright © 2024 Anthoine Bourgeois <anthoine.bourgeois@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "wrap.h"

void * __rd_dlsym_helper(const char *name)
{
	static void *libc_dl;
	void *func;

	if (!libc_dl)
		libc_dl = dlopen("/lib/arm-linux-gnueabihf/libc-2.15.so", RTLD_LAZY);
	if (!libc_dl)
		libc_dl = dlopen("/lib/libc-2.16.so", RTLD_LAZY);
	if (!libc_dl)
		libc_dl = dlopen("libc.so.6", RTLD_LAZY);

	if (!libc_dl) {
		printf("Failed to dlopen libc: %s\n", dlerror());
		exit(-1);
	}

	func = dlsym(libc_dl, name);

	if (!func) {
		printf("Failed to find %s: %s\n", name, dlerror());
		exit(-1);
	}

	return func;
}

const char *errornames[] = {
	ENUM_INFO(PVRSRV_OK),
	ENUM_INFO(PVRSRV_ERROR_OUT_OF_MEMORY),
	ENUM_INFO(PVRSRV_ERROR_TOO_FEW_BUFFERS),
	ENUM_INFO(PVRSRV_ERROR_INVALID_PARAMS),
	ENUM_INFO(PVRSRV_ERROR_INIT_FAILURE),
	ENUM_INFO(PVRSRV_ERROR_CANT_REGISTER_CALLBACK),
	ENUM_INFO(PVRSRV_ERROR_INVALID_DEVICE),
	ENUM_INFO(PVRSRV_ERROR_NOT_OWNER),
	ENUM_INFO(PVRSRV_ERROR_BAD_MAPPING),
	ENUM_INFO(PVRSRV_ERROR_TIMEOUT),
	ENUM_INFO(PVRSRV_ERROR_FLIP_CHAIN_EXISTS),
	ENUM_INFO(PVRSRV_ERROR_INVALID_SWAPINTERVAL),
	ENUM_INFO(PVRSRV_ERROR_SCENE_INVALID),
	ENUM_INFO(PVRSRV_ERROR_STREAM_ERROR),
	ENUM_INFO(PVRSRV_ERROR_FAILED_DEPENDENCIES),
	ENUM_INFO(PVRSRV_ERROR_CMD_NOT_PROCESSED),
	ENUM_INFO(PVRSRV_ERROR_CMD_TOO_BIG),
	ENUM_INFO(PVRSRV_ERROR_DEVICE_REGISTER_FAILED),
	ENUM_INFO(PVRSRV_ERROR_TOOMANYBUFFERS),
	ENUM_INFO(PVRSRV_ERROR_NOT_SUPPORTED),
	ENUM_INFO(PVRSRV_ERROR_PROCESSING_BLOCKED),
	ENUM_INFO(PVRSRV_ERROR_CANNOT_FLUSH_QUEUE),
	ENUM_INFO(PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE),
	ENUM_INFO(PVRSRV_ERROR_CANNOT_GET_RENDERDETAILS),
	ENUM_INFO(PVRSRV_ERROR_RETRY),
	ENUM_INFO(PVRSRV_ERROR_DDK_VERSION_MISMATCH),
	ENUM_INFO(PVRSRV_ERROR_BUILD_MISMATCH),
	ENUM_INFO(PVRSRV_ERROR_CORE_REVISION_MISMATCH),
	ENUM_INFO(PVRSRV_ERROR_UPLOAD_TOO_BIG),
	ENUM_INFO(PVRSRV_ERROR_INVALID_FLAGS),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_REGISTER_PROCESS),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_LOAD_LIBRARY),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_GET_FUNC_ADDR),
	ENUM_INFO(PVRSRV_ERROR_UNLOAD_LIBRARY_FAILED),
	ENUM_INFO(PVRSRV_ERROR_BRIDGE_CALL_FAILED),
	ENUM_INFO(PVRSRV_ERROR_IOCTL_CALL_FAILED),
	ENUM_INFO(PVRSRV_ERROR_MMU_CONTEXT_NOT_FOUND),
	ENUM_INFO(PVRSRV_ERROR_BUFFER_DEVICE_NOT_FOUND),
	ENUM_INFO(PVRSRV_ERROR_BUFFER_DEVICE_ALREADY_PRESENT),
	ENUM_INFO(PVRSRV_ERROR_PCI_DEVICE_NOT_FOUND),
	ENUM_INFO(PVRSRV_ERROR_PCI_CALL_FAILED),
	ENUM_INFO(PVRSRV_ERROR_PCI_REGION_TOO_SMALL),
	ENUM_INFO(PVRSRV_ERROR_PCI_REGION_UNAVAILABLE),
	ENUM_INFO(PVRSRV_ERROR_BAD_REGION_SIZE_MISMATCH),
	ENUM_INFO(PVRSRV_ERROR_REGISTER_BASE_NOT_SET),
	ENUM_INFO(PVRSRV_ERROR_BM_BAD_SHAREMEM_HANDLE),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_ALLOC_USER_MEM),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_ALLOC_VP_MEMORY),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_MAP_SHARED_PBDESC),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_GET_PHYS_ADDR),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_ALLOC_VIRT_MEMORY),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_COPY_VIRT_MEMORY),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_ALLOC_PAGES),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_FREE_PAGES),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_COPY_PAGES),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_LOCK_PAGES),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_UNLOCK_PAGES),
	ENUM_INFO(PVRSRV_ERROR_STILL_MAPPED),
	ENUM_INFO(PVRSRV_ERROR_MAPPING_NOT_FOUND),
	ENUM_INFO(PVRSRV_ERROR_PHYS_ADDRESS_EXCEEDS_32BIT),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_MAP_PAGE_TABLE),
	ENUM_INFO(PVRSRV_ERROR_INVALID_SEGMENT_BLOCK),
	ENUM_INFO(PVRSRV_ERROR_INVALID_SGXDEVDATA),
	ENUM_INFO(PVRSRV_ERROR_INVALID_DEVINFO),
	ENUM_INFO(PVRSRV_ERROR_INVALID_MEMINFO),
	ENUM_INFO(PVRSRV_ERROR_INVALID_MISCINFO),
	ENUM_INFO(PVRSRV_ERROR_UNKNOWN_IOCTL),
	ENUM_INFO(PVRSRV_ERROR_INVALID_CONTEXT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_DESTROY_CONTEXT),
	ENUM_INFO(PVRSRV_ERROR_INVALID_HEAP),
	ENUM_INFO(PVRSRV_ERROR_INVALID_KERNELINFO),
	ENUM_INFO(PVRSRV_ERROR_UNKNOWN_POWER_STATE),
	ENUM_INFO(PVRSRV_ERROR_INVALID_HANDLE_TYPE),
	ENUM_INFO(PVRSRV_ERROR_INVALID_WRAP_TYPE),
	ENUM_INFO(PVRSRV_ERROR_INVALID_PHYS_ADDR),
	ENUM_INFO(PVRSRV_ERROR_INVALID_CPU_ADDR),
	ENUM_INFO(PVRSRV_ERROR_INVALID_HEAPINFO),
	ENUM_INFO(PVRSRV_ERROR_INVALID_PERPROC),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_RETRIEVE_HEAPINFO),
	ENUM_INFO(PVRSRV_ERROR_INVALID_MAP_REQUEST),
	ENUM_INFO(PVRSRV_ERROR_INVALID_UNMAP_REQUEST),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_FIND_MAPPING_HEAP),
	ENUM_INFO(PVRSRV_ERROR_MAPPING_STILL_IN_USE),
	ENUM_INFO(PVRSRV_ERROR_EXCEEDED_HW_LIMITS),
	ENUM_INFO(PVRSRV_ERROR_NO_STAGING_BUFFER_ALLOCATED),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_CREATE_PERPROC_AREA),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_CREATE_EVENT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_REGISTER_EVENT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_DESTROY_EVENT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_CREATE_THREAD),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_CLOSE_THREAD),
	ENUM_INFO(PVRSRV_ERROR_THREAD_READ_ERROR),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_REGISTER_ISR_HANDLER),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_UNINSTALL_ISR),
	ENUM_INFO(PVRSRV_ERROR_ISR_ALREADY_INSTALLED),
	ENUM_INFO(PVRSRV_ERROR_ISR_NOT_INSTALLED),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_INITIALISE_INTERRUPT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_RETRIEVE_INFO),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_DO_BACKWARDS_BLIT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_CLOSE_SERVICES),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_REGISTER_CONTEXT),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_REGISTER_RESOURCE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_CLOSE_HANDLE),
	ENUM_INFO(PVRSRV_ERROR_INVALID_CCB_COMMAND),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_LOCK_RESOURCE),
	ENUM_INFO(PVRSRV_ERROR_INVALID_LOCK_ID),
	ENUM_INFO(PVRSRV_ERROR_RESOURCE_NOT_LOCKED),
	ENUM_INFO(PVRSRV_ERROR_FLIP_FAILED),
	ENUM_INFO(PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED),
	ENUM_INFO(PVRSRV_ERROR_TIMEOUT_POLLING_FOR_VALUE),
	ENUM_INFO(PVRSRV_ERROR_CREATE_RENDER_CONTEXT_FAILED),
	ENUM_INFO(PVRSRV_ERROR_UNKNOWN_PRIMARY_FRAG),
	ENUM_INFO(PVRSRV_ERROR_UNEXPECTED_SECONDARY_FRAG),
	ENUM_INFO(PVRSRV_ERROR_UNEXPECTED_PRIMARY_FRAG),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_INSERT_FENCE_ID),
	ENUM_INFO(PVRSRV_ERROR_BLIT_SETUP_FAILED),
	ENUM_INFO(PVRSRV_ERROR_PDUMP_NOT_AVAILABLE),
	ENUM_INFO(PVRSRV_ERROR_PDUMP_BUFFER_FULL),
	ENUM_INFO(PVRSRV_ERROR_PDUMP_BUF_OVERFLOW),
	ENUM_INFO(PVRSRV_ERROR_PDUMP_NOT_ACTIVE),
	ENUM_INFO(PVRSRV_ERROR_INCOMPLETE_LINE_OVERLAPS_PAGES),
	ENUM_INFO(PVRSRV_ERROR_MUTEX_DESTROY_FAILED),
	ENUM_INFO(PVRSRV_ERROR_MUTEX_INTERRUPTIBLE_ERROR),
	ENUM_INFO(PVRSRV_ERROR_INSUFFICIENT_SCRIPT_SPACE),
	ENUM_INFO(PVRSRV_ERROR_INSUFFICIENT_SPACE_FOR_COMMAND),
	ENUM_INFO(PVRSRV_ERROR_PROCESS_NOT_INITIALISED),
	ENUM_INFO(PVRSRV_ERROR_PROCESS_NOT_FOUND),
	ENUM_INFO(PVRSRV_ERROR_SRV_CONNECT_FAILED),
	ENUM_INFO(PVRSRV_ERROR_SRV_DISCONNECT_FAILED),
	ENUM_INFO(PVRSRV_ERROR_DEINT_PHASE_FAILED),
	ENUM_INFO(PVRSRV_ERROR_INIT2_PHASE_FAILED),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_FIND_RESOURCE),
	ENUM_INFO(PVRSRV_ERROR_NO_DC_DEVICES_FOUND),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_OPEN_DC_DEVICE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_REMOVE_DEVICE),
	ENUM_INFO(PVRSRV_ERROR_NO_DEVICEDATA_FOUND),
	ENUM_INFO(PVRSRV_ERROR_NO_DEVICENODE_FOUND),
	ENUM_INFO(PVRSRV_ERROR_NO_CLIENTNODE_FOUND),
	ENUM_INFO(PVRSRV_ERROR_FAILED_TO_PROCESS_QUEUE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_INIT_TASK),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_SCHEDULE_TASK),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_KILL_TASK),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_ENABLE_TIMER),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_DISABLE_TIMER),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_REMOVE_TIMER),
	ENUM_INFO(PVRSRV_ERROR_UNKNOWN_PIXEL_FORMAT),
	ENUM_INFO(PVRSRV_ERROR_UNKNOWN_SCRIPT_OPERATION),
	ENUM_INFO(PVRSRV_ERROR_HANDLE_INDEX_OUT_OF_RANGE),
	ENUM_INFO(PVRSRV_ERROR_HANDLE_NOT_ALLOCATED),
	ENUM_INFO(PVRSRV_ERROR_HANDLE_TYPE_MISMATCH),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_ADD_HANDLE),
	ENUM_INFO(PVRSRV_ERROR_HANDLE_NOT_SHAREABLE),
	ENUM_INFO(PVRSRV_ERROR_HANDLE_NOT_FOUND),
	ENUM_INFO(PVRSRV_ERROR_INVALID_SUBHANDLE),
	ENUM_INFO(PVRSRV_ERROR_HANDLE_BATCH_IN_USE),
	ENUM_INFO(PVRSRV_ERROR_HANDLE_BATCH_COMMIT_FAILURE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_CREATE_HASH_TABLE),
	ENUM_INFO(PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED),
	ENUM_INFO(PVRSRV_ERROR_UNSUPPORTED_BACKING_STORE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_DESTROY_BM_HEAP),
	ENUM_INFO(PVRSRV_ERROR_UNKNOWN_INIT_SERVER_STATE),
	ENUM_INFO(PVRSRV_ERROR_NO_FREE_DEVICEIDS_AVALIABLE),
	ENUM_INFO(PVRSRV_ERROR_INVALID_DEVICEID),
	ENUM_INFO(PVRSRV_ERROR_DEVICEID_NOT_FOUND),
	ENUM_INFO(PVRSRV_ERROR_MEMORY_TEST_FAILED),
	ENUM_INFO(PVRSRV_ERROR_CPUPADDR_TEST_FAILED),
	ENUM_INFO(PVRSRV_ERROR_COPY_TEST_FAILED),
	ENUM_INFO(PVRSRV_ERROR_SEMAPHORE_NOT_INITIALISED),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_RELEASE_CLOCK),
	ENUM_INFO(PVRSRV_ERROR_CLOCK_REQUEST_FAILED),
	ENUM_INFO(PVRSRV_ERROR_DISABLE_CLOCK_FAILURE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_SET_CLOCK_RATE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_ROUND_CLOCK_RATE),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_ENABLE_CLOCK),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_GET_CLOCK),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_GET_PARENT_CLOCK),
	ENUM_INFO(PVRSRV_ERROR_UNABLE_TO_GET_SYSTEM_CLOCK),
	ENUM_INFO(PVRSRV_ERROR_UNKNOWN_SGL_ERROR),
	ENUM_INFO(PVRSRV_ERROR_SYSTEM_POWER_CHANGE_FAILURE),
	ENUM_INFO(PVRSRV_ERROR_DEVICE_POWER_CHANGE_FAILURE),
	ENUM_INFO(PVRSRV_ERROR_BAD_SYNC_STATE),
	ENUM_INFO(PVRSRV_ERROR_CACHEOP_FAILED),
	ENUM_INFO(PVRSRV_ERROR_CACHE_INVALIDATE_FAILED)
};

void print_error(PVRSRV_ERROR error)
{
	const char *errorname =
	        (error < ARRAY_SIZE(errornames)) ?
		errornames[error] : NULL;
	printf("\t\terror:\t\t%08x (%s)\n", error,
		errorname ? errorname : "unknown");
}

const char *sgx_heap_id[] = {
    ENUM_INFO(SGX_GENERAL_HEAP_ID),
    ENUM_INFO(SGX_TADATA_HEAP_ID),
    ENUM_INFO(SGX_KERNEL_CODE_HEAP_ID),
    ENUM_INFO(SGX_KERNEL_DATA_HEAP_ID),
    ENUM_INFO(SGX_PIXELSHADER_HEAP_ID),
    ENUM_INFO(SGX_VERTEXSHADER_HEAP_ID),
    ENUM_INFO(SGX_PDSPIXEL_CODEDATA_HEAP_ID),
    ENUM_INFO(SGX_PDSVERTEX_CODEDATA_HEAP_ID),
    ENUM_INFO(SGX_SYNCINFO_HEAP_ID),
    ENUM_INFO(SGX_SHARED_3DPARAMETERS_HEAP_ID),
    ENUM_INFO(SGX_PERCONTEXT_3DPARAMETERS_HEAP_ID),
#if defined(SUPPORT_SGX_GENERAL_MAPPING_HEAP)
    ENUM_INFO(SGX_GENERAL_MAPPING_HEAP_ID),
#endif
#if defined(SGX_FEATURE_2D_HARDWARE)
    ENUM_INFO(SGX_2D_HEAP_ID),
#else
#if defined(FIX_HW_BRN_26915)
    ENUM_INFO(SGX_CGBUFFER_HEAP_ID),
#endif
#endif
    ENUM_INFO(SGX_MAX_HEAP_ID),
};

void print_heapinfo(int i, PVRSRV_HEAP_INFO *heapinfo)
{
    if (heapinfo->ui32HeapID != 0xffffffff) {
	printf("\t\theap ID[%d]:\t%08x (%s)\n", i, heapinfo->ui32HeapID, sgx_heap_id[HEAP_IDX(heapinfo->ui32HeapID)]);
	printf("\t\tdevmem heap:\t%p\n", heapinfo->hDevMemHeap);
	printf("\t\tdev vaddr base:\t%08x\n", heapinfo->sDevVAddrBase.uiAddr);
	printf("\t\theap byte size:\t%u\n", heapinfo->ui32HeapByteSize);
        print_attribs(heapinfo->ui32Attribs);
	printf("\t\tX tile stride:\t%08x\n", heapinfo->ui32XTileStride);
    }
}

#define ENUM_MEM(n) [n] = "PVRSRV_"#n
enum pvrsrv_mem {
	MEM_READ,
	MEM_WRITE,
	MEM_CACHE_CONSISTENT,
	MEM_NO_SYNCOBJ,
	MEM_INTERLEAVED,
	MEM_DUMMY,
	MEM_EDM_PROTECT,
	MEM_ZERO,
	MEM_USER_SUPPLIED_DEVVADDR,
	MEM_RAM_BACKED_ALLOCATION,
	MEM_NO_RESMAN,
	MEM_EXPORTED,
        HAP_CACHED,
        HAP_UNCACHED,
        HAP_WRITECOMBINE,
        HAP_KERNEL_ONLY,
        HAP_SINGLE_PROCESS,
        HAP_MULTI_PROCESS,
        HAP_FROM_EXISTING_PROCESS,
        HAP_NO_CPU_VIRTUAL,
        MAP_GC_MMU,
        HAP_GPU_PAGEABLE,
        HAP_NO_GPU_VIRTUAL_ON_ALLOC,
        MEM_UNUSED23,
        MEM_BACKINGSTORE_FIELD24_INTERNAL,
        MEM_BACKINGSTORE_FIELD25_INTERNAL,
        MEM_BACKINGSTORE_FIELD26_INTERNAL,
        MAP_NOUSERVIRTUAL,
        MEM_XPROC,
        MEM_ION,
        MEM_ALLOCATENONCACHEDMEM,
};
static const char *memnames[] = {
	ENUM_MEM(MEM_READ),
	ENUM_MEM(MEM_WRITE),
	ENUM_MEM(MEM_CACHE_CONSISTENT),
	ENUM_MEM(MEM_NO_SYNCOBJ),
	ENUM_MEM(MEM_INTERLEAVED),
	ENUM_MEM(MEM_DUMMY),
	ENUM_MEM(MEM_EDM_PROTECT),
	ENUM_MEM(MEM_ZERO),
	ENUM_MEM(MEM_USER_SUPPLIED_DEVVADDR),
	ENUM_MEM(MEM_RAM_BACKED_ALLOCATION),
	ENUM_MEM(MEM_NO_RESMAN),
	ENUM_MEM(MEM_EXPORTED),
        ENUM_MEM(HAP_CACHED),
        ENUM_MEM(HAP_UNCACHED),
        ENUM_MEM(HAP_WRITECOMBINE),
        ENUM_MEM(HAP_KERNEL_ONLY),
        ENUM_MEM(HAP_SINGLE_PROCESS),
        ENUM_MEM(HAP_MULTI_PROCESS),
        ENUM_MEM(HAP_FROM_EXISTING_PROCESS),
        ENUM_MEM(HAP_NO_CPU_VIRTUAL),
        ENUM_MEM(MAP_GC_MMU),
        ENUM_MEM(HAP_GPU_PAGEABLE),
        ENUM_MEM(HAP_NO_GPU_VIRTUAL_ON_ALLOC),
        ENUM_MEM(MEM_UNUSED23),
        ENUM_MEM(MEM_BACKINGSTORE_FIELD24_INTERNAL),
        ENUM_MEM(MEM_BACKINGSTORE_FIELD25_INTERNAL),
        ENUM_MEM(MEM_BACKINGSTORE_FIELD26_INTERNAL),
        ENUM_MEM(MAP_NOUSERVIRTUAL),
        ENUM_MEM(MEM_XPROC),
        ENUM_MEM(MEM_ION),
        ENUM_MEM(MEM_ALLOCATENONCACHEDMEM),
};
void print_attribs(IMG_UINT32 attribs)
{
	int previous = 0;
	int flag;
	int i;
	const char *memname;

	printf("\t\tattribs:\t%08x (", attribs);

	for (i = 0; i < 32; i++)
	{
		flag = 1 << i;
		if (attribs & flag) {
			if (previous)
				printf(" | ");
			previous = 1;

			memname = (i < ARRAY_SIZE(memnames)) ? memnames[i] : NULL;
			if (memname)
				printf("%s", memname);
			else
				printf("unknown mem attribut 0x%x", flag);
		}
	}

	printf(")\n");
}

void print_eventobject(PVRSRV_EVENTOBJECT *eventobject)
{
	if (!eventobject) {
		return;
	}

	printf("\t\tname:\t\t'%s'\n", eventobject->szName);
	printf("\t\tos evt km:\t%p\n", eventobject->hOSEventKM);
}

const char *cacheopnames[] = {
		ENUM_INFO(PVRSRV_MISC_INFO_CPUCACHEOP_NONE),
		ENUM_INFO(PVRSRV_MISC_INFO_CPUCACHEOP_CLEAN),
		ENUM_INFO(PVRSRV_MISC_INFO_CPUCACHEOP_FLUSH)
};
void print_miscinfo(PVRSRV_MISC_INFO *miscinfo)
{
	const char *cacheopname;
	int i;

	if (!miscinfo) {
		return;
	}

	printf("\t\tstate req:\t%08x\n", miscinfo->ui32StateRequest);
	printf("\t\tstate prst:\t%08x\n", miscinfo->ui32StatePresent);
	printf("\t\tsoctimer km:\t%p\n", miscinfo->pvSOCTimerRegisterKM);
	printf("\t\tsoctimer um:\t%p\n", miscinfo->pvSOCTimerRegisterUM);
	printf("\t\tsoctimer osmem:\t%p\n", miscinfo->hSOCTimerRegisterOSMemHandle);
	printf("\t\tsoctimer map:\t%p\n", miscinfo->hSOCTimerRegisterMappingInfo);
	printf("\t\tsoc clkgate:\t%p\n", miscinfo->pvSOCClockGateRegs);
	printf("\t\tsoc clkgate sz:\t%08x\n", miscinfo->ui32SOCClockGateRegsSize);
	printf("\t\tmemstr:\t\t%p\n", miscinfo->pszMemoryStr);
	printf("\t\tmemstr sz:\t%08x\n", miscinfo->ui32MemoryStrLen);
	print_eventobject(&miscinfo->sGlobalEventObject);
	printf("\t\tos global evt:\t%p\n", miscinfo->hOSGlobalEvent);
	for (i = 0; i < 4; i++) {
		printf("\t\tddk version[%d]:\t%08x\n", i, miscinfo->aui32DDKVersion[i]);
	}
	printf("\t\tcache defer:\t%s\n", miscinfo->sCacheOpCtl.bDeferOp ? "true" : "false");
	cacheopname =
		(miscinfo->sCacheOpCtl.eCacheOpType < ARRAY_SIZE(cacheopnames)) ?
		cacheopnames[miscinfo->sCacheOpCtl.eCacheOpType] : NULL;
	printf("\t\tcache type:\t%08x (%s)\n", miscinfo->sCacheOpCtl.eCacheOpType,
		cacheopname ? cacheopname : "unknown");
#if !defined (SUPPORT_SID_INTERFACE)
	printf("\t\tclient mem:\t%p\n", miscinfo->sCacheOpCtl.u.psClientMemInfo);
#endif
	printf("\t\tbase vaddr:\t%p\n", miscinfo->sCacheOpCtl.pvBaseVAddr);
	printf("\t\tlength:\t\t%08x\n", miscinfo->sCacheOpCtl.ui32Length);
}
